{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-chart",
  "type": "registry:component",
  "title": "Line Chart",
  "description": "A customizable line chart component using Recharts.",
  "dependencies": [
    "recharts",
    "tailwind-variants",
    "@remixicon/react"
  ],
  "registryDependencies": [
    "utils",
    "badge"
  ],
  "files": [
    {
      "path": "registry/default/line-chart/line-chart.tsx",
      "content": "// Tremor Raw LineChart [v0.0.0]\n\n\"use client\"\n\nimport { RiArrowLeftSLine, RiArrowRightSLine } from \"@remixicon/react\"\nimport React from \"react\"\nimport {\n  CartesianGrid,\n  Dot,\n  Label,\n  Line,\n  Legend as RechartsLegend,\n  LineChart as RechartsLineChart,\n  ResponsiveContainer,\n  Tooltip,\n  XAxis,\n  YAxis,\n} from \"recharts\"\nimport { AxisDomain } from \"recharts/types/util/types\"\n\nimport {\n  AvailableChartColors,\n  AvailableChartColorsKeys,\n  constructCategoryColors,\n  getColorClassName,\n  getYAxisDomain,\n  hasOnlyOneValueForKey,\n} from \"@/registry/default/line-chart/lib/chart-utils\"\nimport { useOnWindowResize } from \"@/registry/default/line-chart/lib/use-on-window-resize\"\nimport { cx } from \"@/registry/default/utils/utils\"\n\n// getBadgeType function from the dashboard component\nexport const getBadgeType = (value: number) => {\n  if (value > 0) {\n    return \"success\"\n  } else if (value < 0) {\n    if (value < -50) {\n      return \"warning\"\n    }\n    return \"error\"\n  } else {\n    return \"neutral\"\n  }\n}\n\n//#region Legend\n\ninterface LegendItemProps {\n  name: string\n  color: AvailableChartColorsKeys\n  onClick?: (name: string, color: AvailableChartColorsKeys) => void\n  activeLegend?: string\n}\n\nconst LegendItem = ({\n  name,\n  color,\n  onClick,\n  activeLegend,\n}: LegendItemProps) => {\n  const hasOnValueChange = !!onClick\n  return (\n    <li\n      className={cx(\n        // base\n        \"group inline-flex flex-nowrap items-center gap-1.5 whitespace-nowrap rounded px-2 py-1 transition\",\n        hasOnValueChange\n          ? \"bg-transpaent cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800\"\n          : \"cursor-default\",\n      )}\n      onClick={(e) => {\n        e.stopPropagation()\n        onClick?.(name, color)\n      }}\n    >\n      <span\n        className={cx(\n          \"h-[3px] w-3.5 shrink-0 rounded-full\",\n          getColorClassName(color, \"bg\"),\n          activeLegend && activeLegend !== name ? \"opacity-40\" : \"opacity-100\",\n        )}\n        aria-hidden=\"true\"\n      />\n      <p\n        className={cx(\n          // base\n          \"truncate whitespace-nowrap text-xs\",\n          // text color\n          \"text-gray-700 dark:text-gray-300\",\n          hasOnValueChange &&\n            \"group-hover:text-gray-900 dark:group-hover:text-gray-50\",\n          activeLegend && activeLegend !== name ? \"opacity-40\" : \"opacity-100\",\n        )}\n      >\n        {name}\n      </p>\n    </li>\n  )\n}\ninterface ScrollButtonProps {\n  icon: React.ElementType\n  onClick?: () => void\n  disabled?: boolean\n}\n\nconst ScrollButton = ({ icon, onClick, disabled }: ScrollButtonProps) => {\n  const Icon = icon\n  const [isPressed, setIsPressed] = React.useState(false)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n\n  React.useEffect(() => {\n    if (isPressed) {\n      intervalRef.current = setInterval(() => {\n        onClick?.()\n      }, 300)\n    } else {\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n    }\n    return () => clearInterval(intervalRef.current as NodeJS.Timeout)\n  }, [isPressed, onClick])\n\n  React.useEffect(() => {\n    if (disabled) {\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n      setIsPressed(false)\n    }\n  }, [disabled])\n\n  return (\n    <button\n      type=\"button\"\n      className={cx(\n        // base\n        \"group inline-flex size-5 items-center truncate rounded transition\",\n        disabled\n          ? \"cursor-not-allowed text-gray-400 dark:text-gray-600\"\n          : \"cursor-pointer text-gray-700 hover:bg-gray-100 hover:text-gray-900 dark:text-gray-300 dark:hover:bg-gray-800 dark:hover:text-gray-50\",\n      )}\n      disabled={disabled}\n      onClick={onClick}\n      onMouseDown={() => setIsPressed(true)}\n      onMouseUp={() => setIsPressed(false)}\n    >\n      <Icon className=\"size-3\" aria-hidden=\"true\" />\n    </button>\n  )\n}\n\ninterface LegendProps extends React.OlHTMLAttributes<HTMLOListElement> {\n  categories: string[]\n  colors?: AvailableChartColorsKeys[]\n  onClickLegendItem?: (category: string, color: string) => void\n  activeLegend?: string\n  enableLegendSlider?: boolean\n}\n\ntype HasScrollProps = {\n  left: boolean\n  right: boolean\n}\n\nconst Legend = React.forwardRef<HTMLOListElement, LegendProps>(\n  (\n    {\n      categories,\n      colors = AvailableChartColors,\n      className,\n      onClickLegendItem,\n      activeLegend,\n      enableLegendSlider = false,\n      ...props\n    },\n    forwardedRef,\n  ) => {\n    const scrollableRef = React.useRef<HTMLInputElement>(null)\n    const scrollButtonsRef = React.useRef<HTMLDivElement>(null)\n    const [hasScroll, setHasScroll] = React.useState<HasScrollProps | null>(\n      null,\n    )\n    const [isKeyDowned, setIsKeyDowned] = React.useState<string | null>(null)\n    const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n\n    const checkScroll = React.useCallback(() => {\n      const scrollable = scrollableRef?.current\n      if (!scrollable) return\n\n      const hasLeftScroll = scrollable.scrollLeft > 0\n      const hasRightScroll =\n        scrollable.scrollWidth - scrollable.clientWidth >\n        scrollable.scrollLeft\n\n      setHasScroll({ left: hasLeftScroll, right: hasRightScroll })\n    }, [setHasScroll])\n\n    const scrollToTest = React.useCallback(\n      (direction: \"left\" | \"right\") => {\n        const element = scrollableRef?.current\n        const scrollButtons = scrollButtonsRef?.current\n        const scrollButtonsWith = scrollButtons?.clientWidth ?? 0\n        const width = element?.clientWidth ?? 0\n\n        if (element && enableLegendSlider) {\n          element.scrollTo({\n            left:\n              direction === \"left\"\n                ? element.scrollLeft - width + scrollButtonsWith\n                : element.scrollLeft + width - scrollButtonsWith,\n            behavior: \"smooth\",\n          })\n          setTimeout(() => {\n            checkScroll()\n          }, 400)\n        }\n      },\n      [enableLegendSlider, checkScroll],\n    )\n\n    React.useEffect(() => {\n      const keyDownHandler = (key: string) => {\n        if (key === \"ArrowLeft\") {\n          scrollToTest(\"left\")\n        } else if (key === \"ArrowRight\") {\n          scrollToTest(\"right\")\n        }\n      }\n      if (isKeyDowned) {\n        keyDownHandler(isKeyDowned)\n        intervalRef.current = setInterval(() => {\n          keyDownHandler(isKeyDowned)\n        }, 300)\n      } else {\n        clearInterval(intervalRef.current as NodeJS.Timeout)\n      }\n      return () => clearInterval(intervalRef.current as NodeJS.Timeout)\n    }, [isKeyDowned, scrollToTest])\n\n    const keyDown = (e: KeyboardEvent) => {\n      e.preventDefault()\n      if (e.code === \"ArrowLeft\" || e.code === \"ArrowRight\") {\n        setIsKeyDowned(e.code)\n      }\n    }\n    const keyUp = (e: KeyboardEvent) => {\n      e.preventDefault()\n      setIsKeyDowned(null)\n    }\n\n    React.useEffect(() => {\n      const scrollable = scrollableRef?.current\n      if (enableLegendSlider) {\n        checkScroll()\n        scrollable?.addEventListener(\"keydown\", keyDown)\n        scrollable?.addEventListener(\"keyup\", keyUp)\n\n        // clean up if unmount\n        return () => {\n          scrollable?.removeEventListener(\"keydown\", keyDown)\n          scrollable?.removeEventListener(\"keyup\", keyUp)\n        }\n      }\n    }, [checkScroll, enableLegendSlider])\n\n    return (\n      <ol\n        ref={forwardedRef}\n        className={cx(\"relative overflow-hidden\", className)}\n        {...props}\n      >\n        <div\n          ref={scrollableRef}\n          tabIndex={0}\n          className={cx(\n            \"flex h-full\",\n            enableLegendSlider\n              ? \"snap-x snap-mandatory overflow-auto pl-4 pr-12 [scrollbar-width:none] [&::-webkit-scrollbar]:hidden\"\n              : \"flex-wrap\",\n          )}\n        >\n          {categories.map((category, index) => (\n            <LegendItem\n              key={`item-${index}`}\n              name={category}\n              color={colors[index] as AvailableChartColorsKeys}\n              onClick={onClickLegendItem}\n              activeLegend={activeLegend}\n            />\n          ))}\n        </div>\n        {enableLegendSlider && (\n          <div\n            ref={scrollButtonsRef}\n            className={cx(\n              \"absolute bottom-0 right-0 top-0 flex h-full items-center justify-center pr-1\",\n              \"bg-white dark:bg-gray-950\",\n            )}\n          >\n            <ScrollButton\n              icon={RiArrowLeftSLine}\n              onClick={() => {\n                setIsKeyDowned(null)\n                scrollToTest(\"left\")\n              }}\n              disabled={!hasScroll?.left}\n            />\n            <ScrollButton\n              icon={RiArrowRightSLine}\n              onClick={() => {\n                setIsKeyDowned(null)\n                scrollToTest(\"right\")\n              }}\n              disabled={!hasScroll?.right}\n            />\n          </div>\n        )}\n      </ol>\n    )\n  },\n)\n\nLegend.displayName = \"Legend\"\n\n//#endregion\n\ninterface ChartTooltipRowProps {\n  value: string\n  name: string\n  color: string\n}\n\nconst ChartTooltipRow = ({ value, name, color }: ChartTooltipRowProps) => (\n  <div className=\"flex items-center justify-between space-x-8\">\n    <div className=\"flex items-center space-x-2\">\n      <span\n        aria-hidden=\"true\"\n        className={cx(\"h-[3px] w-3.5 shrink-0 rounded-full\", color)}\n      />\n      <p\n        className={cx(\n          // base\n          \"whitespace-nowrap text-right\",\n          // text color\n          \"text-gray-700 dark:text-gray-300\",\n        )}\n      >\n        {name}\n      </p>\n    </div>\n    <p\n      className={cx(\n        // base\n        \"whitespace-nowrap text-right font-medium tabular-nums\",\n        // text color\n        \"text-gray-900 dark:text-gray-50\",\n      )}\n    >\n      {value}\n    </p>\n  </div>\n)\n\ninterface ChartTooltipProps {\n  active: boolean | undefined\n  payload: any\n  label: string\n  categoryColors: Map<string, AvailableChartColorsKeys>\n  valueFormatter: (value: number) => string\n}\n\nconst ChartTooltip = ({\n  active,\n  payload,\n  label,\n  categoryColors,\n  valueFormatter,\n}: ChartTooltipProps) => {\n  if (active && payload && payload.length) {\n    return (\n      <div\n        className={cx(\n          // base\n          \"rounded-md border text-sm shadow-md\",\n          // border color\n          \"border-gray-200 dark:border-gray-800\",\n          // background color\n          \"bg-white dark:bg-gray-950\",\n        )}\n      >\n        <div className={cx(\"border-b border-inherit px-4 py-2\")}>\n          <p\n            className={cx(\n              // base\n              \"font-medium\",\n              // text color\n              \"text-gray-900 dark:text-gray-50\",\n            )}\n          >\n            {label}\n          </p>\n        </div>\n\n        <div className={cx(\"space-y-1 px-4 py-2\")}>\n          {payload\n            .sort((a: any, b: any) => b.value - a.value)\n            .map((item: any, index: number) => (\n              <ChartTooltipRow\n                key={`id-${index}`}\n                value={valueFormatter(item.value)}\n                name={item.dataKey}\n                color={getColorClassName(\n                  categoryColors.get(item.dataKey) as AvailableChartColorsKeys,\n                  \"bg\",\n                )}\n              />\n            ))}\n        </div>\n      </div>\n    )\n  }\n  return null\n}\n\n//#region LineChart\n\nexport interface LineChartProps\n  extends React.HTMLAttributes<HTMLDivElement> {\n  data: Record<string, any>[]\n  index: string\n  categories: string[]\n  colors?: AvailableChartColorsKeys[]\n  valueFormatter?: (value: number) => string\n  startEndOnly?: boolean\n  showXAxis?: boolean\n  showYAxis?: boolean\n  showGridLines?: boolean\n  yAxisWidth?: number\n  intervalType?: \"preserveStartEnd\" | \"equidistantPreserveStart\"\n  showTooltip?: boolean\n  showLegend?: boolean\n  autoMinValue?: boolean\n  minValue?: number\n  maxValue?: number\n  allowDecimals?: boolean\n  connectNulls?: boolean\n  noDataText?: string\n  onValueChange?: (value: any, category: string) => void\n  enableLegendSlider?: boolean\n  tickGap?: number\n  xAxisLabel?: string\n  yAxisLabel?: string\n}\n\nconst LineChart = React.forwardRef<HTMLDivElement, LineChartProps>(\n  (\n    {\n      data = [],\n      categories = [],\n      index,\n      colors = AvailableChartColors,\n      valueFormatter = (value: number) => value.toString(),\n      startEndOnly = false,\n      showXAxis = true,\n      showYAxis = true,\n      showGridLines = true,\n      yAxisWidth = 56,\n      intervalType = \"equidistantPreserveStart\",\n      showTooltip = true,\n      showLegend = true,\n      autoMinValue = false,\n      minValue,\n      maxValue,\n      allowDecimals = true,\n      connectNulls = false,\n      noDataText,\n      className,\n      onValueChange,\n      enableLegendSlider = false,\n      tickGap = 5,\n      xAxisLabel,\n      yAxisLabel,\n      ...props\n    },\n    forwardedRef,\n  ) => {\n    const CustomTooltip = React.useCallback(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (props: any) => {\n        const { active, payload, label } = props\n        return (\n          <ChartTooltip\n            active={active}\n            payload={payload}\n            label={label}\n            valueFormatter={valueFormatter}\n            categoryColors={categoryColors}\n          />\n        )\n      },\n      [valueFormatter],\n    )\n\n    const [legendHeight, setLegendHeight] = React.useState(60)\n    const [activeDot, setActiveDot] = React.useState<any>(undefined)\n    const [activeLegend, setActiveLegend] = React.useState<string | undefined>(\n      undefined,\n    )\n    const categoryColors = constructCategoryColors(categories, colors)\n\n    const yAxisDomain = getYAxisDomain(autoMinValue, minValue, maxValue)\n    const hasOnValueChange = !!onValueChange\n\n    function onDotClick(itemData: any, event: React.MouseEvent) {\n      event.stopPropagation()\n\n      if (!hasOnValueChange) return\n      if (\n        (itemData.index === activeDot?.index &&\n          itemData.dataKey === activeDot?.dataKey) ||\n        (hasOnlyOneValueForKey(data, itemData.dataKey) &&\n          activeLegend &&\n          activeLegend === itemData.dataKey)\n      ) {\n        setActiveDot(undefined)\n        onValueChange?.(null, \"\")\n      } else {\n        setActiveDot({\n          index: itemData.index,\n          dataKey: itemData.dataKey,\n        })\n        onValueChange?.(itemData, itemData.dataKey)\n      }\n    }\n\n    function onCategoryClick(dataKey: string) {\n      if (!hasOnValueChange) return\n      if (\n        (dataKey === activeLegend && !activeDot) ||\n        (hasOnlyOneValueForKey(data, dataKey) &&\n          activeDot &&\n          activeDot.dataKey === dataKey)\n      ) {\n        setActiveLegend(undefined)\n        onValueChange?.(null, \"\")\n      } else {\n        setActiveLegend(dataKey)\n        onValueChange?.(data.map((entry) => entry[dataKey]), dataKey)\n      }\n    }\n\n    const legendRef = React.useRef<HTMLDivElement>(null)\n\n    useOnWindowResize(() => {\n      const calculateHeight = (height: number | undefined) =>\n        height ? Number(height) + 15 : 60\n      setLegendHeight(calculateHeight(legendRef.current?.clientHeight))\n    })\n\n    const filteredData = data.filter((item) => item[index] !== undefined)\n\n    return (\n      <div ref={forwardedRef} className={cx(\"w-full\", className)} {...props}>\n        <ResponsiveContainer width=\"100%\" height=\"100%\">\n          <RechartsLineChart\n            data={filteredData}\n            onClick={\n              hasOnValueChange && (activeLegend || activeDot)\n                ? () => {\n                    setActiveLegend(undefined)\n                    setActiveDot(undefined)\n                    onValueChange?.(null, \"\")\n                  }\n                : undefined\n            }\n            margin={{\n              bottom: showXAxis ? 20 : 5,\n              left: showYAxis ? 20 : 5,\n              right: showYAxis ? 5 : 5,\n              top: 5,\n            }}\n          >\n            {showGridLines ? (\n              <CartesianGrid\n                className={cx(\"stroke-gray-200 stroke-1 dark:stroke-gray-800\")}\n                horizontal={true}\n                vertical={false}\n              />\n            ) : null}\n            <XAxis\n              hide={!showXAxis}\n              dataKey={index}\n              tick={{ transform: \"translate(0, 6)\" }}\n              ticks={\n                startEndOnly\n                  ? [filteredData[0]?.[index], filteredData[filteredData.length - 1]?.[index]]\n                  : undefined\n              }\n              fill=\"\"\n              stroke=\"\"\n              className={cx(\n                // base\n                \"text-xs\",\n                // text fill\n                \"fill-gray-500 dark:fill-gray-500\",\n              )}\n              tickLine={false}\n              axisLine={false}\n              minTickGap={tickGap}\n              interval={startEndOnly ? 0 : intervalType}\n            >\n              {xAxisLabel && (\n                <Label\n                  position=\"insideBottom\"\n                  offset={-5}\n                  className=\"fill-gray-800 text-sm font-medium dark:fill-gray-200\"\n                >\n                  {xAxisLabel}\n                </Label>\n              )}\n            </XAxis>\n            <YAxis\n              width={yAxisWidth}\n              hide={!showYAxis}\n              axisLine={false}\n              tickLine={false}\n              type=\"number\"\n              domain={yAxisDomain as AxisDomain}\n              tick={{ transform: \"translate(-3, 0)\" }}\n              fill=\"\"\n              stroke=\"\"\n              className={cx(\n                // base\n                \"text-xs\",\n                // text fill\n                \"fill-gray-500 dark:fill-gray-500\",\n              )}\n              tickFormatter={valueFormatter}\n              allowDecimals={allowDecimals}\n            >\n              {yAxisLabel && (\n                <Label\n                  angle={-90}\n                  position=\"insideLeft\"\n                  style={{ textAnchor: \"middle\" }}\n                  className=\"fill-gray-800 text-sm font-medium dark:fill-gray-200\"\n                >\n                  {yAxisLabel}\n                </Label>\n              )}\n            </YAxis>\n            <Tooltip\n              wrapperStyle={{ outline: \"none\" }}\n              isAnimationActive={true}\n              animationDuration={100}\n              cursor={{ stroke: \"#374151\", strokeWidth: 1 }}\n              offset={20}\n              position={{ y: 0 }}\n              content={showTooltip ? CustomTooltip : <></>}\n            />\n            {showLegend ? (\n              <RechartsLegend\n                verticalAlign=\"top\"\n                height={legendHeight}\n                content={({ payload }) =>\n                  payload ? (\n                    <div\n                      ref={legendRef}\n                      className={cx(\"flex items-center\", {\n                        \"justify-center\": !enableLegendSlider,\n                      })}\n                    >\n                      <Legend\n                        categories={payload.map((entry: any) => entry.value)}\n                        colors={payload.map((entry: any) =>\n                          categoryColors.get(entry.value) || \"blue\",\n                        )}\n                        onClickLegendItem={onCategoryClick}\n                        activeLegend={activeLegend}\n                        enableLegendSlider={enableLegendSlider}\n                      />\n                    </div>\n                  ) : null\n                }\n              />\n            ) : null}\n            {categories.map((category) => (\n              <Line\n                className={cx(\n                  getColorClassName(\n                    categoryColors.get(category) as AvailableChartColorsKeys,\n                    \"stroke\",\n                  ),\n                )}\n                strokeOpacity={\n                  activeLegend && activeLegend !== category ? 0.3 : 1\n                }\n                activeDot={(props: any) => {\n                  const {\n                    cx: cxCoord,\n                    cy: cyCoord,\n                    stroke,\n                    strokeLinecap,\n                    strokeLinejoin,\n                    strokeWidth,\n                    dataKey,\n                  } = props\n                  return (\n                    <Dot\n                      className={cx(\n                        \"stroke-white dark:stroke-gray-950\",\n                        onValueChange ? \"cursor-pointer\" : \"\",\n                        getColorClassName(\n                          categoryColors.get(dataKey) as AvailableChartColorsKeys,\n                          \"fill\",\n                        ),\n                      )}\n                      cx={cxCoord}\n                      cy={cyCoord}\n                      r={5}\n                      fill=\"\"\n                      stroke={stroke}\n                      strokeLinecap={strokeLinecap}\n                      strokeLinejoin={strokeLinejoin}\n                      strokeWidth={strokeWidth}\n                      onClick={(_: any, event: React.MouseEvent) =>\n                        onDotClick(props, event)\n                      }\n                    />\n                  )\n                }}\n                dot={(props: any) => {\n                  const {\n                    stroke,\n                    strokeLinecap,\n                    strokeLinejoin,\n                    strokeWidth,\n                    cx: cxCoord,\n                    cy: cyCoord,\n                    dataKey,\n                    index,\n                  } = props\n\n                  if (\n                    (hasOnValueChange &&\n                      (activeDot || (activeLegend && activeLegend !== dataKey))) ||\n                    (activeDot?.index === index && activeDot?.dataKey === dataKey)\n                  ) {\n                    return (\n                      <Dot\n                        key={index}\n                        cx={cxCoord}\n                        cy={cyCoord}\n                        r={5}\n                        stroke={stroke}\n                        fill=\"\"\n                        strokeLinecap={strokeLinecap}\n                        strokeLinejoin={strokeLinejoin}\n                        strokeWidth={strokeWidth}\n                        className={cx(\n                          \"stroke-white dark:stroke-gray-950\",\n                          onValueChange ? \"cursor-pointer\" : \"\",\n                          getColorClassName(\n                            categoryColors.get(dataKey) as AvailableChartColorsKeys,\n                            \"fill\",\n                          ),\n                        )}\n                      />\n                    )\n                  }\n                  return <Dot key={index} r={0} stroke={stroke} fill=\"\" />\n                }}\n                key={category}\n                dataKey={category}\n                stroke=\"\"\n                strokeWidth={2}\n                strokeLinejoin=\"round\"\n                strokeLinecap=\"round\"\n                type=\"linear\"\n                connectNulls={connectNulls}\n              />\n            ))}\n            {/* hidden lines to increase click target area */}\n            {onValueChange\n              ? categories.map((category) => (\n                  <Line\n                    className={cx(\"cursor-pointer\")}\n                    strokeOpacity={0}\n                    key={category}\n                    dataKey={category}\n                    stroke=\"transparent\"\n                    fill=\"transparent\"\n                    legendType=\"none\"\n                    tooltipType=\"none\"\n                    strokeWidth={12}\n                    connectNulls={connectNulls}\n                    onClick={(props: any, event: React.MouseEvent) => {\n                      event.stopPropagation()\n                      onDotClick(props, event)\n                    }}\n                  />\n                ))\n              : null}\n          </RechartsLineChart>\n        </ResponsiveContainer>\n\n        {noDataText && filteredData.length === 0 ? (\n          <div className=\"flex h-full items-center justify-center\">\n            <p\n              className={cx(\n                // base\n                \"text-sm\",\n                // text color\n                \"text-gray-500 dark:text-gray-500\",\n              )}\n            >\n              {noDataText}\n            </p>\n          </div>\n        ) : null}\n      </div>\n    )\n  },\n)\n\nLineChart.displayName = \"LineChart\"\n\n//#endregion\n\nexport { LineChart, type LineChartProps }",
      "type": "registry:component"
    },
    {
      "path": "registry/default/line-chart/lib/chart-utils.ts",
      "content": "// Tremor Raw chartColors [v0.0.0]\n\nexport type ColorUtility = \"bg\" | \"stroke\" | \"fill\" | \"text\"\n\nexport const chartColors = {\n  blue: {\n    bg: \"bg-blue-500\",\n    stroke: \"stroke-blue-500\",\n    fill: \"fill-blue-500\",\n    text: \"text-blue-500\",\n  },\n  emerald: {\n    bg: \"bg-emerald-500\",\n    stroke: \"stroke-emerald-500\",\n    fill: \"fill-emerald-500\",\n    text: \"text-emerald-500\",\n  },\n  violet: {\n    bg: \"bg-violet-500\",\n    stroke: \"stroke-violet-500\",\n    fill: \"fill-violet-500\",\n    text: \"text-violet-500\",\n  },\n  amber: {\n    bg: \"bg-amber-500\",\n    stroke: \"stroke-amber-500\",\n    fill: \"fill-amber-500\",\n    text: \"text-amber-500\",\n  },\n  gray: {\n    bg: \"bg-gray-400 dark:bg-gray-600\",\n    stroke: \"stroke-gray-400 dark:stroke-gray-600\",\n    fill: \"fill-gray-400 dark:fill-gray-600\",\n    text: \"text-gray-400 dark:text-gray-600\",\n  },  cyan: {\n    bg: \"bg-cyan-500\",\n    stroke: \"stroke-cyan-500\",\n    fill: \"fill-cyan-500\",\n    text: \"text-cyan-500\",\n  },\n  indigo: {\n    bg: \"bg-indigo-600 dark:bg-indigo-500\",\n    stroke: \"stroke-indigo-600 dark:stroke-indigo-500\",\n    fill: \"fill-indigo-600 dark:fill-indigo-500\",\n    text: \"text-indigo-600 dark:text-indigo-500\",\n  },\n  pink: {\n    bg: \"bg-pink-500\",\n    stroke: \"stroke-pink-500\",\n    fill: \"fill-pink-500\",\n    text: \"text-pink-500\",\n  },\n} as const satisfies {\n  [color: string]: {\n    [key in ColorUtility]: string\n  }\n}\n\nexport type AvailableChartColorsKeys = keyof typeof chartColors\n\nexport const AvailableChartColors: AvailableChartColorsKeys[] = Object.keys(\n  chartColors,\n) as Array<AvailableChartColorsKeys>\n\nexport const constructCategoryColors = (\n  categories: string[],\n  colors: AvailableChartColorsKeys[],\n): Map<string, AvailableChartColorsKeys> => {\n  const categoryColors = new Map<string, AvailableChartColorsKeys>()\n  categories.forEach((category, index) => {\n    categoryColors.set(category, colors[index % colors.length])\n  })\n  return categoryColors\n}\nexport const getColorClassName = (\n  color: AvailableChartColorsKeys,\n  type: ColorUtility,\n): string => {\n  const fallbackColor = {\n    bg: \"bg-gray-500\",\n    stroke: \"stroke-gray-500\",\n    fill: \"fill-gray-500\",\n    text: \"text-gray-500\",\n  }\n  return chartColors[color]?.[type] ?? fallbackColor[type]\n}\n\n// Tremor Raw getYAxisDomain [v0.0.0]\n\nexport const getYAxisDomain = (\n  autoMinValue: boolean,\n  minValue: number | undefined,\n  maxValue: number | undefined,\n) => {\n  const minDomain = autoMinValue ? \"auto\" : (minValue ?? 0)\n  const maxDomain = maxValue ?? \"auto\"\n  return [minDomain, maxDomain]\n}\n\n// Tremor Raw hasOnlyOneValueForKey [v0.1.0]\n\nexport function hasOnlyOneValueForKey(\n  array: any[],\n  keyToCheck: string,\n): boolean {\n  const val: any[] = []\n\n  for (const obj of array) {\n    if (Object.prototype.hasOwnProperty.call(obj, keyToCheck)) {\n      val.push(obj[keyToCheck])\n      if (val.length > 1) {\n        return false\n      }\n    }\n  }\n\n  return true\n}",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/line-chart/lib/use-on-window-resize.tsx",
      "content": "// Tremor Raw useOnWindowResize [v0.0.0]\n\nimport * as React from \"react\"\n\nexport const useOnWindowResize = (handler: { (): void }) => {\n  React.useEffect(() => {\n    const handleResize = () => {\n      handler()\n    }\n    handleResize()\n    window.addEventListener(\"resize\", handleResize)\n\n    return () => window.removeEventListener(\"resize\", handleResize)\n  }, [handler])\n}",
      "type": "registry:hook"
    }
  ]
}